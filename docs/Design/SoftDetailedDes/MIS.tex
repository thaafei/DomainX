\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{array}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{3cm}X}
\toprule {\bf Date} & {\bf Developer(s)} & {\bf Change}\\
\midrule
Nov 12, 2025 & Awurama & Rev -1\\
Jan 19, 2026 & Awurama & Rev 0 Based on feedback\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\href{https://github.com/thaafei/DomainX/blob/main/docs/SRS/SRS.pdf}{SRS Documentation}.

This section records acronyms and abbreviations for easy reference. 
Additional terms specific to the Module Interface Specification (MIS) are included below.

\begin{longtable}{@{}l p{0.72\textwidth}@{}}
\caption{Symbols, Abbreviations, and Acronyms}\\
\toprule
\textbf{Symbol / Acronym} & \textbf{Description}\\
\midrule
\endfirsthead

\toprule
\textbf{Symbol / Acronym} & \textbf{Description}\\
\midrule
\endhead

\midrule
\multicolumn{2}{r}{\small Continued on next page}
\\\bottomrule
\endfoot

\bottomrule
\endlastfoot

AC & Anticipated Change. \\
ADT & Abstract Data Type. \\
AHP & Analytic Hierarchy Process, method for pairwise comparison and ranking of libraries. \\
AI & Artificial Intelligence. \\
API & Application Programming Interface, mechanism for data retrieval (e.g., GitHub API, PyPI API). \\
BWM & Best–Worst Method. \\
CAS & Computing and Software Department (McMaster University). \\
CI/CD & Continuous Integration / Continuous Deployment, automated testing and deployment pipeline used in GitHub Actions. \\
CSV & Comma-Separated Values, used as an export format for datasets. \\
DAG & Directed Acyclic Graph. \\
DB & Database, a MySQL instance used for persistent data storage. \\
Domain & Research Software Domain. \\
Excel Sheets & Existing manual tools previously used for data collection. \\
Infrastructure & University-provided resources such as hosting, databases, and servers. \\
JSON & JavaScript Object Notation, data interchange format used by the system’s APIs. \\
LLM & Large Language Model. \\
M & Module. \\
MG & Module Guide. \\
MIS & Module Interface Specification (this document). \\
ML & Machine Learning. \\
NN & Neural Network. \\
NNL & Neural Network Libraries. \\
ORM & Object Relational Mapper, Django ORM used for database interactions. \\
OS & Operating System. \\
Packages & Software Packages. \\
PoC & Proof of Concept, demonstration validating workflow integration. \\
R & Requirement. \\
REST API & Representational State Transfer API, communication style used between the frontend (React) and backend (Django). \\
Research Subteam & Student group applying the methodology and writing the research paper. \\
SC & Scientific Computing. \\
SFWRENG 4G06 & Capstone Design Process. \\
SRS & Software Requirements Specification. \\
SSB & Skew-Symmetric Bilinear. \\
Stakeholders & All individuals involved in or affected by the project (e.g., supervisor, researchers, domain expert). \\
Supervisor & Faculty member overseeing the project. \\
Tool & The software being developed to automate data collection, visualization, and storage. \\
UI & User Interface, front-end component built with React. \\
UI/UX & User Interface and User Experience. \\
UC & Unlikely Change. \\
VnV & Verification and Validation, process of ensuring correctness and meeting stakeholder needs. \\
HTTP & Hypertext Transfer Protocol, application-layer protocol for transmitting web resources. \\
HTTPS & Hypertext Transfer Protocol Secure, encrypted version of HTTP using TLS. \\
CORS & Cross-Origin Resource Sharing, browser security mechanism controlling cross-domain HTTP requests. \\
\end{longtable}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the \textbf{Module Interface Specifications (MIS)} for the 
\textbf{Domain Assessment Tool}, a web-based system that automates data collection, 
analysis, and visualization to evaluate different research domains. 
The system enables users to systematically compare libraries, frameworks, or technologies 
by applying a structured methodology that combines both quantitative metrics and 
qualitative insights.

The Domain Assessment Tool is structured as a client-server system with a user interface,
an application logic layer, and a persistent storage layer. Components communicate through
well-defined module interfaces using serialized request/response data. Technology and
framework choices are treated as design decisions captured in the MG and implementation
artifacts, and are not required to interpret the module interfaces specified in this MIS.


Complementary documents include the 
\href{https://github.com/thaafei/DomainX/blob/main/docs/SRS/SRS.pdf}
{System Requirements Specification (SRS)} and the 
\href{https://github.com/thaafei/DomainX/blob/main/docs/Design/SoftArchitecture/MG.pdf}
{Module Guide (MG)}. 
The full documentation and implementation are maintained in the project’s GitHub repository at 
\href{https://github.com/thaafei/DomainX}{DomainX}.


\section{Notation}

The \textbf{Module Interface Specification (MIS)} follows the notation and principles of 
\citet{HoffmanAndStrooper1995}, with adaptations from \citet{GhezziEtAl2003}. 
Mathematical conventions align with Chapter 3 of \citet{HoffmanAndStrooper1995} and 
notations used in \textbf{SFWRENG 4G06 – Capstone Design Process}.  

\subsection{General Conventions}

\begin{itemize}
  \item \textbf{Assignment:} \texttt{x := e}
  \item \textbf{Conditional rules:} 
        $(c_1 \Rightarrow r_1\ |\ c_2 \Rightarrow r_2\ |\ \dots\ |\ c_n \Rightarrow r_n)$
  \item \textbf{Parameter modes:} \texttt{in}, \texttt{out}
  \item \textbf{Optional parameter:} \texttt{[param]}
  \item \textbf{Exceptions:} functions list \texttt{ExceptionName} in an 
        \emph{Exceptions} column; raising an exception denotes a partial function 
        on the exceptional domain.
  \item \textbf{Pre/postconditions:} \texttt{requires P} / \texttt{ensures Q}
  \item \textbf{Undefined value / error sentinel:} $\bot$
  \item \textbf{Outputs:} \texttt{out := e}
  \item \textbf{Exceptions:} \texttt{exc := ExceptionName}
\end{itemize}

\subsection{Logic and Set Notation}

\begin{itemize}
  \item \textbf{Logical operators:} $\neg$, $\land$, $\lor$, $\Rightarrow$, $\Leftrightarrow$
  \item \textbf{Quantifiers:} $\forall x \in S \cdot P(x)$, $\exists x \in S \cdot P(x)$
  \item \textbf{Sets:} $\emptyset$, $\{x \in S | P(x)\}$, union $A \cup B$, intersection $A \cap B$, difference $A \setminus B$, cardinality $|S|$
  \item \textbf{Sequences/lists:} $(a_1,\dots,a_n)$; concatenation $s \| t$; length $|s|$
  \item \textbf{Maps/dictionaries:} $m : K \rightarrow V$; application $m(k)$; update $m[k \mapsto v]$
\end{itemize}

\subsection{Primitive and Derived Types}
\label{tab:primitive-derived-types}
\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l l X}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
character & \texttt{char} & Single Unicode character. \\
integer & $\mathbb{Z}$ & Whole numbers in $(-\infty,\infty)$. \\
natural number & $\mathbb{N}$ & Non-negative integers $(0,1,2,\dots)$. \\
real & $\mathbb{R}$ & Real numbers. \\
boolean & \texttt{bool} & \texttt{True} or \texttt{False}. \\
string & \texttt{string} & Finite sequence of characters. \\
tuple & \texttt{(T$_1$,…,T$_n$)} & Fixed-size, ordered collection, possibly heterogeneous. \\
list / sequence & \texttt{list(T)} & Variable-size sequence of T. \\
set & $\mathcal{P}(T)$ & Finite subset of T (power-set elements). \\
dictionary / map & \texttt{dict(K,V)} & Finite mapping from K to V. \\
option / optional type & \texttt{Option(T)} & Either \texttt{Some(T)} or \texttt{None}. \\
\bottomrule
\end{tabularx}
\caption{Primitive and Derived Data Types}
\end{table}

\subsection{Units and Identifiers}

\begin{itemize}
  \item \textbf{Timestamps:} use ISO 8601 (e.g., 2025-11-11T09:30:00Z).  
  \item \textbf{Durations:} explicit units (e.g., \texttt{min}, \texttt{hrs}).  
  \item \textbf{Identifiers:} \texttt{domainID}, \texttt{metricID}, and \texttt{packageID} are opaque strings unless otherwise specified.
\end{itemize}

\noindent
These conventions are used to define interfaces, state variables, environment variables, and access routines throughout the MIS. Derived structures (lists, maps, sets, tuples) represent collections of domain records, configuration parameters, and request/response data.. Local functions are defined by their type signatures and input/output relationships.


\section{Module Decomposition}

The following table (Table~\ref{tab:module-hierarchy}) summarizes the hierarchical organization of modules for the Domain Assessment Tool.  
Level 1 modules correspond to high-level abstraction layers, while Level 2 modules provide specific functionality within each layer.

\begin{table}[H]
\centering
\caption{Module Hierarchy}
\label{tab:module-hierarchy}
\setlength{\tabcolsep}{10pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X}
\toprule
\textbf{Level 1} & \textbf{Level 2} \\
\midrule
Hardware-Hiding Module & Browser Module \\
\midrule
Behaviour-Hiding Module &
Domains Page Module \\
& Application UI Module \\
& Data Edit Module \\
& User Authentication Module \\
& User Role Access Module \\
& User Page Module \\
& Automated Metrics Module \\
& Comparison Module \\
& Configuration Module \\
\midrule
Software Decision Module &
System API Gateway Module \\
& Ranking Algorithm Module \\
& Graphing Module \\
& File Import Module \\
& File Export Module \\
& Repository API Module \\
& Database Persistence Module \\
& Logging Module \\
\bottomrule
\end{tabularx}
\end{table}

\newpage






\section{Module Interface Specifications}
%   cross-referencing}

% \wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

% \wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

% \subsection{Module}

% \wss{Short name for the module}

% \subsection{Uses}


% \subsection{Syntax}

% \subsubsection{Exported Constants}

% \subsubsection{Exported Access Programs}

% \begin{center}
% \begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
% \hline
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \hline
% \wss{accessProg} & - & - & - \\
% \hline
% \end{tabular}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}

% \wss{Not all modules will have state variables.  State variables give the module
%   a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture
%   when the module has external interaction with the environment, such as for a
%   device driver, screen interface, keyboard, file, etc.}

% \subsubsection{Assumptions}

% \wss{Try to minimize assumptions and anticipate programmer errors via
%   exceptions, but for practical purposes assumptions are sometimes appropriate.}

% \subsubsection{Access Routine Semantics}

% \noindent \wss{accessProg}():
% \begin{itemize}
% \item transition: \wss{if appropriate} 
% \item output: \wss{if appropriate} 
% \item exception: \wss{if appropriate} 
% \end{itemize}

% \wss{A module without environment variables or state variables is unlikely to
%   have a state transition.  In this case a state transition can only occur if
%   the module is changing the state of another module.}

% \wss{Modules rarely have both a transition and an output.  In most cases you
%   will have one or the other.}

% \subsubsection{Local Functions}

% \wss{As appropriate} \wss{These functions are for the purpose of specification.
%   They are not necessarily something that is going to be implemented
%   explicitly.  Even if they are implemented, they are not exported; they only
%   have local scope.}


\subsection{MIS of Browser Module (M2)}
\label{mis:Browser}

\subsubsection{Module}
Provides the runtime container for the client application. The browser renders markup and
style content, maintains the Document Object Model (DOM), collects user input (mouse,
keyboard), and provides networking and storage facilities used by the client.


\subsubsection{Uses}
None (external, platform-provided).

\subsubsection{Syntax}
\paragraph{Exported Constants} None.  % External module, no constants exported by our system.

\paragraph{Exported Access Programs} None. % The browser exposes standard Web APIs, not part of our codebase.

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{domTree}: the in-memory Document Object Model for the current page.
  \item \textbf{cookieStore}: key–value cookie storage scoped to the site.
  \item \textbf{localStorage}/\textbf{sessionStorage}: Web Storage used by the UI for small client-side state.
  \item \textbf{cache}: HTTP/resource cache managed by the browser.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{domTree} is a well-formed DOM representation for the currently loaded page.
  \item \textbf{cookieStore}, \textbf{localStorage}, and \textbf{sessionStorage} map string keys to string values.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{screen}: the display device used to render the client interface.
  \item \textbf{inputDevices}: user input sources (mouse, keyboard, touch) that generate events.
  \item \textbf{net}: the network interface used to send and receive requests to external services.
  \item \textbf{clock}: a system clock used for timeouts, caching, and session expiry.
\end{itemize}



\paragraph{Assumptions}
\begin{itemize}
  \item A modern standards-compliant browser (Chromium/Chrome, Firefox, Safari).
  \item Supports HTML5, ECMAScript 2020+, Fetch API, CORS, and Web Storage.
  \item The system is served over HTTPS and external services accept and return serialized request/response data.
\end{itemize}

\paragraph{Access Routine Semantics}
Not applicable (no routines exported by this module in our system).

\paragraph{Local Functions}

\begin{itemize}
  \item \textit{renderPage}(): Updates the Document Object Model in response to
        application state changes.
  \item \textit{handleUserInput}(e): Captures and dispatches user input events
        (mouse, keyboard) to the front-end logic.
  \item \textit{sendRequest}(req): Issues network requests to backend services
        using the browser networking stack.
  \item \textit{updateStorage}(k, v): Reads from and writes to localStorage or
        sessionStorage as required by the UI.
\end{itemize}

\subsection{MIS of Application UI Module (M3)}
\label{mis:ApplicationUI}

\subsubsection{Module}
Provides the client application shell (routing, layout, and common UI state) that renders
pages and components of the DomainX system and connects user interactions to the rest of
the system through the defined module interfaces.


\subsubsection{Uses}
Browser Module (M2) (\ref{mis:Browser})\\
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
Graphing Module (M12) (\ref{mis:GraphingModule})\\
File Import Module (M13) (\ref{mis:FileImportModule})\\
File Export Module (M14) (\ref{mis:FileExportModule})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{APP\_TITLE} = ``DomainX''
  \item \textbf{DEFAULT\_ROUTE} = ``/domains''
  \item \textbf{TOAST\_DURATION\_MS} = 4000
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
initAppShell & none & mountedRoot & RenderError \\
navigateTo & routeID, [params] & renderedView & RouteNotFound \\
renderComponent & componentID, props & renderedFragment & RenderError \\
handleUserAction & actionType, payload & dispatchResult & ActionError \\
showNotification & message, severity & successFlag & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{currentRoute}: the active route (path and params).
  \item \textbf{uiState}: global UI model (loading flags, toasts, modal state).
  \item \textbf{sessionContext}: authenticated user + role snapshot for conditional rendering.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{currentRoute} is a valid route identifier supported by the UI.
  \item \textbf{uiState} is well-formed (e.g., toast queue length $\geq 0$, modal state is consistent).
  \item \textbf{sessionContext} is either \texttt{None} (unauthenticated) or contains a valid user identifier and role snapshot.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{screen}: display surface used to render the user interface (provided via M2).
  \item \textbf{inputDevices}: user input sources (mouse, keyboard, touch) that generate UI events (via M2).
  \item \textbf{net}: network interface used to send and receive requests to external services (via M2).
  \item \textbf{clock}: system clock used for timeouts and session timing (via M2).
\end{itemize}


\paragraph{Assumptions}
\begin{itemize}
  \item Executed within the Browser Module (M2), which provides DOM rendering, event delivery, storage, and networking facilities.
  \item Network I/O occurs exclusively through the System API Gateway Module (M10); backend endpoints are not embedded in the UI.
  \item Graphs are rendered via M12; file workflows are delegated to M13/M14.
\end{itemize}



\paragraph{Access Routine Semantics}

\noindent \textbf{initAppShell}():
\begin{itemize}
  \item transition: initializes the UI shell, registers routing, and initializes global UI/session state.
  \item output: \texttt{mountedRoot}.
  \item exception: \texttt{RenderError} if bootstrap fails.
\end{itemize}

\noindent \textbf{navigateTo}(routeID, [params]):
\begin{itemize}
  \item transition: updates \texttt{currentRoute}; triggers route component render.
  \item output: \texttt{renderedView}.
  \item exception: \texttt{RouteNotFound} if routeID unknown.
\end{itemize}

\noindent \textbf{renderComponent}(componentID, props):
\begin{itemize}
  \item transition: none (pure render of a component into the view tree).
  \item output: \texttt{renderedFragment}.
  \item exception: \texttt{RenderError} if component fails to render.
\end{itemize}

\noindent \textbf{handleUserAction}(actionType, payload):
\begin{itemize}
  \item transition: may update \texttt{uiState}; may delegate to M10/M12/M13/M14/M15 via callbacks.
  \item output: \texttt{dispatchResult} (ack/nack).
  \item exception: \texttt{ActionError} on invalid action/payload.
\end{itemize}

\noindent \textbf{showNotification}(message, severity):
\begin{itemize}
  \item transition: enqueues a toast into \texttt{uiState} for \texttt{TOAST\_DURATION\_MS}.
  \item output: \texttt{successFlag}.
  \item exception: none.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{guardByRole()} — checks \texttt{sessionContext} to gate routes/components.
  \item \texttt{bindGraphHandlers()} — wires chart events (M12) to UI callbacks.
  \item \texttt{confirmBeforeLeave()} — prompts on unsaved changes before navigation.
\end{itemize}


\subsection{MIS of Data Edit Module (M4)}
\label{mis:DataEdit}

\subsubsection{Module}
Handles user-initiated edits to domain, package, and metric data. Provides client-side validation and coordinates save/delete operations through the System API Gateway.

\subsubsection{Uses}
Application UI Module (M3) (\ref{mis:ApplicationUI})\\
User Authentication Module (M5) (\ref{mis:UserAuthentication})\\
User Role Access Module (M6) (\ref{mis:UserRoleAccess})\\
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{MAX\_EDIT\_BATCH} = 50
  \item \textbf{UNDO\_STACK\_LIMIT} = 10
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.15}
\begin{tabularx}{\textwidth}{l X X c}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
addMetric & metricData & successFlag & SchemaError \\
editMetric & metricID, newValue & successFlag & ValidationError \\
deleteMetric & metricID & successFlag & NotFoundError \\
undoLastEdit & -- & successFlag & StackEmptyError \\
validateEdit & candidateChange & bool & ValidationError \\
commitBatch & changeList & successFlag & NetworkError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{editBuffer}: pending changes not yet committed.
  \item \textbf{undoStack}: most recent operations up to \texttt{UNDO\_STACK\_LIMIT}.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{inputDevices}: user input sources (mouse, keyboard, touch) that generate edit events.
  \item \textbf{screen}: the display surface used to render edit forms and validation feedback.
  \item \textbf{net}: network interface used to send requests to the backend via M10 (HTTPS/JSON).
  \item \textbf{clock}: system clock used for timeouts and request expiry (if applicable).
\end{itemize}


\paragraph{Assumptions}
\begin{itemize}
  \item The user is authenticated (M5) and authorized (M6) for the requested action.
  \item Executed within a browser-based React UI; form state and feedback are managed by M3.
  \item Network I/O is performed through M10 over HTTPS using JSON payloads conforming to M10 schemas.
  \item Persistent storage of edits is performed by M17 \emph{via} M10 (M4 does not access M17 directly).
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{addMetric}(metricData):
\begin{itemize}
  \item transition: validate \texttt{metricData}; stage in \texttt{editBuffer}; on commit, send create request via M10 to M17.
  \item output: \texttt{successFlag} = true if accepted by backend.
  \item exception: \texttt{SchemaError} if required fields are missing or malformed.
\end{itemize}

\noindent \textbf{editMetric}(metricID, newValue):
\begin{itemize}
  \item transition: stage field updates in \texttt{editBuffer}; mark record dirty.
  \item output: \texttt{successFlag} = true on commit acknowledgement.
  \item exception: \texttt{ValidationError} if new value violates schema or business rules.
\end{itemize}

\noindent \textbf{deleteMetric}(metricID):
\begin{itemize}
  \item transition: stage delete action in \texttt{editBuffer}.
  \item output: \texttt{successFlag} = true if deletion is confirmed by M17 (via M10).
  \item exception: \texttt{NotFoundError} if the metric does not exist.
\end{itemize}

\noindent \textbf{undoLastEdit}():
\begin{itemize}
  \item transition: revert the most recent staged or committed change if reversible; update \texttt{undoStack}.
  \item output: \texttt{successFlag} = true if an action was undone.
  \item exception: \texttt{StackEmptyError} if there is nothing to undo.
\end{itemize}

\noindent \textbf{validateEdit}(candidateChange):
\begin{itemize}
  \item transition: none (local validation only).
  \item output: Boolean indicating whether \texttt{candidateChange} satisfies client-side checks.
  \item exception: \texttt{ValidationError} if checks fail.
\end{itemize}

\noindent \textbf{commitBatch}(changeList):
\begin{itemize}
  \item transition: send up to \texttt{MAX\_EDIT\_BATCH} staged changes via M10; clear successful items from \texttt{editBuffer}; push entries to \texttt{undoStack}.
  \item output: \texttt{successFlag} = true if all changes are acknowledged by M17.
  \item exception: \texttt{NetworkError} if API calls fail or time out.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{coerceTypes()} — cast user input to expected types.
  \item \texttt{diffRecords()} — compute minimal patch for update requests.
  \item \texttt{throttleSaves()} — coalesce frequent edits before commit.
\end{itemize}


\subsection{MIS of User Authentication Module (M5)}
\label{mis:UserAuthentication}

\subsubsection{Module}
Provides user authentication and session management services for the system.
This module validates credentials, issues and invalidates authentication tokens,
and tracks active user sessions through a well-defined interface exposed to
other modules.


\subsubsection{Uses}
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
User Role Access Module (M6) (\ref{mis:UserRoleAccess})\\
Database Persistence Module (M17) (\ref{mis:DatabasePersistenceModule})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{TOKEN\_EXPIRY\_HOURS} = 24
  \item \textbf{MAX\_LOGIN\_ATTEMPTS} = 5
  \item \textbf{PASSWORD\_MIN\_LENGTH} = 8
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
sendInvite & email, role & inviteCode & AuthError \\
registerUser & email, password, inviteCode & authToken & ValidationError \\
loginUser & email, password & authToken & AuthError \\
logoutUser & authToken & successFlag & SessionError \\
validateSession & authToken & bool & TokenError \\
refreshToken & oldToken & newToken & TokenExpiredError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{activeSessions}: map of valid tokens to user IDs and expiry timestamps.
  \item \textbf{failedAttempts}: counter tracking consecutive failed login attempts.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item Every entry in \textbf{activeSessions} maps a valid authentication token
        to exactly one user identifier and an expiry timestamp.
  \item \textbf{failedAttempts} is a non-negative integer.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{net}: network interface used to receive authentication requests
        and return responses via M10.
  \item \textbf{clock}: system clock used to evaluate token expiry and session timeouts.
\end{itemize}


\paragraph{Assumptions}
\begin{itemize}
  \item Authentication is token-based; issued tokens uniquely identify users and
      have a finite validity period.
  \item All credential transmissions occur via HTTPS.
  \item The UI (M3) performs basic client-side validation before requests are sent.
  \item Tokens expire after \texttt{TOKEN\_EXPIRY\_HOURS}.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{registerUser}(email, password, inviteCode):
\begin{itemize}
  \item transition: validate \texttt{inviteCode}; if valid, create a new user in M17 with a hashed password and the role associated with the invite.
  \item output: \texttt{authToken} if registration succeeds.
  \item exception: \texttt{ValidationError} if email exists, password fails checks, or \texttt{inviteCode} is invalid/expired.
\end{itemize}

\noindent \textbf{sendInvite}(email, role):
\begin{itemize}
  \item transition: generate an invitation code tied to \texttt{email} and \texttt{role}; store the invite and send the code to the user.
  \item output: \texttt{inviteCode}.
  \item exception: \texttt{AuthError} if the requester is not authorized to invite users.
\end{itemize}

\noindent \textbf{loginUser}(email, password):
\begin{itemize}
  \item transition: validate credentials; issue JWT; add entry to \texttt{activeSessions}.
  \item output: \texttt{authToken}.
  \item exception: \texttt{AuthError} if credentials are invalid or account is locked.
\end{itemize}

\noindent \textbf{logoutUser}(authToken):
\begin{itemize}
  \item transition: invalidate token; remove from \texttt{activeSessions}.
  \item output: \texttt{successFlag} = true if successful.
  \item exception: \texttt{SessionError} if session not found.
\end{itemize}

\noindent \textbf{validateSession}(authToken):
\begin{itemize}
  \item transition: none.
  \item output: Boolean indicating if token is valid and unexpired.
  \item exception: \texttt{TokenError} if malformed or tampered.
\end{itemize}

\noindent \textbf{refreshToken}(oldToken):
\begin{itemize}
  \item transition: invalidate old token; issue new JWT with reset expiry.
  \item output: \texttt{newToken}.
  \item exception: \texttt{TokenExpiredError} if token already expired.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{hashPassword()} – securely hashes user credentials.
  \item \texttt{verifyPassword()} – verifies submitted credentials against stored hashes.
  \item \texttt{generateToken()} – issues a signed authentication token.
  \item \texttt{rateLimitLogin()} – blocks login after \texttt{MAX\_LOGIN\_ATTEMPTS}.
\end{itemize}


\subsection{MIS of User Role Access Module (M6)}
\label{mis:UserRoleAccess}

\subsubsection{Module}
Defines, stores, and enforces role-based permissions across the system.
This module determines whether an authenticated user is allowed to perform a
requested action and provides role/permission lookup and update operations to
authorized administrators.

\subsubsection{Uses}
User Authentication Module (M5) (\ref{mis:UserAuthentication})\\
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
Database Persistence Module (M17) (\ref{mis:DatabasePersistenceModule})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_ROLE} = ``Viewer''
  \item \textbf{ROLE\_HIERARCHY} = [``Viewer``, ``Editor``, ``Admin``]
  \item \textbf{PERMISSIONS\_CACHE\_TTL} = 300  \textit{(seconds; cache lifetime for permission lookups)}
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
assignRole & userID, roleName & successFlag & InvalidRoleError \\
getUserRole & userID & roleName & NotFoundError \\
verifyAccess & userID, actionType & bool & PermissionError \\
updateRolePermissions & roleName, newPermissions & successFlag & ConfigError \\
listAllRoles & -- & roleList & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{rolesTable}: mapping of role names to permission sets (read, write, delete, admin).
  \item \textbf{userRoleMap}: dictionary mapping user IDs to assigned roles.
  \item \textbf{permissionsCache}: temporary in-memory store of validated permissions for current session.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item Every entry in \textbf{userRoleMap} maps a valid \texttt{userID} to a role name that appears in \textbf{ROLE\_HIERARCHY}.
  \item \textbf{rolesTable} contains an entry for each role in \textbf{ROLE\_HIERARCHY}.
  \item \textbf{permissionsCache} only stores permissions consistent with \textbf{rolesTable} at the time they were cached.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{net}: network interface used to request and return authorization decisions via M10.
  \item \textbf{clock}: system clock used to evaluate cache expiration for \texttt{PERMISSIONS\_CACHE\_TTL}.
\end{itemize}


\paragraph{Assumptions}
\begin{itemize}
  \item All users are authenticated before authorization checks are performed (via M5).
  \item Each \texttt{actionType} requested by other modules is mapped to a permission category understood by this module.
  \item Role and permission data is stored persistently via M17 and accessed through M10.
\end{itemize}


\paragraph{Access Routine Semantics}

\noindent \textbf{assignRole}(userID, roleName):
\begin{itemize}
  \item transition: updates \texttt{userRoleMap} and backend table with new role.
  \item output: \texttt{successFlag} = true if update is stored.
  \item exception: \texttt{InvalidRoleError} if \texttt{roleName} not found in \texttt{ROLE\_HIERARCHY}.
\end{itemize}

\noindent \textbf{getUserRole}(userID):
\begin{itemize}
  \item transition: none.
  \item output: the user’s current role as a string.
  \item exception: \texttt{NotFoundError} if user not found in table.
\end{itemize}

\noindent \textbf{verifyAccess}(userID, actionType):
\begin{itemize}
  \item transition: none.
  \item output: Boolean — true if role’s permissions include the requested \texttt{actionType}.
  \item exception: \texttt{PermissionError} if unauthorized.
\end{itemize}

\noindent \textbf{updateRolePermissions}(roleName, newPermissions):
\begin{itemize}
  \item transition: modifies \texttt{rolesTable} for the given role and syncs to backend.
  \item output: \texttt{successFlag} = true if successfully updated.
  \item exception: \texttt{ConfigError} if update fails or backend schema mismatch.
\end{itemize}

\noindent \textbf{listAllRoles}():
\begin{itemize}
  \item transition: none.
  \item output: list of available roles and descriptions.
  \item exception: none.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{hasPermission(userID, action)} – returns true if user’s role allows the action.
  \item \texttt{invalidateCache()} – clears cached permissions on role update or logout.
  \item \texttt{syncWithBackend()} – persists role/permission updates via M10.
\end{itemize}


\subsection{MIS of User Page Module (M7)}
\label{mis:UserPage}

\subsubsection{Module}
Implements the interactive user settings page in the DomainX web interface.  
This module displays and updates user account details (e.g., display name, email, password, notification preferences) by issuing requests through the System API Gateway (M10).


\subsubsection{Uses}
User Authentication Module (M5) (\ref{mis:UserAuthentication})\\
User Role Access Module (M6) (\ref{mis:UserRoleAccess})\\
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
Application UI Module (M3) (\ref{mis:ApplicationUI})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{MAX\_DISPLAY\_NAME\_LEN} = 50
  \item \textbf{SESSION\_REFRESH\_INTERVAL} = 15 \textit{(minutes)}
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
fetchUserProfile & authToken & userProfile & AuthError \\
updateUserProfile & authToken, updatedData & successFlag & ValidationError \\
changePassword & authToken, oldPwd, newPwd & successFlag & PasswordError \\
toggleNotifications & authToken, preferenceFlag & successFlag & ConfigError \\
deleteAccount & authToken & successFlag & PermissionError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{userProfile}: object storing current session’s user info (name, email, role, preferences).
  \item \textbf{localCache}: stores recently loaded profile data to reduce repeated API calls.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item If \textbf{localCache} contains profile data, it corresponds to the same authenticated user identified by the current \texttt{authToken}.
  \item \textbf{userProfile} fields respect module constraints (e.g., $|\texttt{displayName}| \le \texttt{MAX\_DISPLAY\_NAME\_LEN}$).
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{net}: network interface used to send profile update requests via M10.
  \item \textbf{clock}: system clock used to schedule session refresh based on \texttt{SESSION\_REFRESH\_INTERVAL}.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item User is authenticated through M5 before accessing the page.
  \item Profile updates require valid session tokens for backend verification.
  \item Password strength and validation follow rules enforced by M5.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{fetchUserProfile}(authToken):
\begin{itemize}
  \item transition: none.
  \item output: returns \texttt{userProfile} containing user’s data.
  \item exception: \texttt{AuthError} if token invalid or expired.
\end{itemize}

\noindent \textbf{updateUserProfile}(authToken, updatedData):
\begin{itemize}
  \item transition: updates local and backend profile data via M10.
  \item output: \texttt{successFlag} = true on confirmation.
  \item exception: \texttt{ValidationError} if new data violates constraints.
\end{itemize}

\noindent \textbf{changePassword}(authToken, oldPwd, newPwd):
\begin{itemize}
  \item transition: validates \texttt{oldPwd}; submits password update request via M10; refreshes \texttt{userProfile} on success.
  \item output: \texttt{successFlag} = true on success.
  \item exception: \texttt{PasswordError} if old password incorrect or new one too weak.
\end{itemize}

\noindent \textbf{toggleNotifications}(authToken, preferenceFlag):
\begin{itemize}
  \item transition: modifies user’s notification preference and syncs to backend.
  \item output: \texttt{successFlag} = true if preference saved.
  \item exception: \texttt{ConfigError} if backend update fails.
\end{itemize}

\noindent \textbf{deleteAccount}(authToken):
\begin{itemize}
  \item transition: issues delete request via M10; user data removed from backend.
  \item output: \texttt{successFlag} = true on completion.
  \item exception: \texttt{PermissionError} if user lacks required authorization.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{cacheProfileData()} – stores profile data locally for faster re-rendering.
  \item \texttt{validateEmailFormat()} – ensures valid email syntax before submission.
  \item \texttt{displayConfirmation()} – shows confirmation prompts for irreversible actions.
\end{itemize}


\subsection{MIS of Automated Metrics Module (M8)}
\label{mis:AutomatedMetrics}

\subsubsection{Module}
Implements the logic for automated retrieval, calculation, and storage of quantitative metrics associated with repositories or packages.  
This module interacts with external APIs through M15 to gather data such as stars, forks, downloads, or commit frequency and stores them in the internal database for further ranking and analysis.

\subsubsection{Uses}
Repository API Module (M15) (\ref{mis:RepositoryAPIModule})\\
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
Ranking Algorithm Module (M11) (\ref{mis:RankingAlgorithm})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{UPDATE\_INTERVAL\_HOURS} = 24
  \item \textbf{MAX\_RETRIES} = 3
  \item \textbf{SUPPORTED\_METRICS} = 
 \item \textbf{SUPPORTED\_METRICS} =
\begin{itemize}
  \item \textbf{GitHub API:} \{stars, forks, watchers, openPullRequests, closedPullRequests\}
  \item \textbf{Git statistics (git\_stats):} \{textFileCount, binaryFileCount, textLineCount, totalLinesAdded, totalLinesDeleted, totalCommits, commitsByYearLastFive, commitsByMonth\}
  \item \textbf{Source code analysis (scc):} \{textFileCount, textLineCount, codeLineCount, commentLineCount, blankLineCount\}
\end{itemize}
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
fetchMetricsFromRepo & packageID & metricsData & APIError \\
validateMetrics & metricsData & bool & ValidationError \\
storeValidatedMetrics & metricsData & successFlag & WriteError \\
enqueueMetricsFetch & packageID & successFlag & QueueError \\
processMetricsQueue & None & successFlag & WorkerError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{metricsQueue}: list of repositories scheduled for update.
  \item \textbf{lastUpdateTime}: timestamp of the last successful metric refresh.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item $\texttt{lastUpdateTime}$ is either \texttt{None} or a valid ISO 8601 timestamp.
  \item Each entry in \texttt{metricsQueue} is a valid \texttt{packageID}.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{net}: network interface used to contact external APIs (via M15) and submit stored metric results (via M10).
  \item \textbf{clock}: system clock used to trigger periodic refresh every \texttt{UPDATE\_INTERVAL\_HOURS}.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item API rate limits are respected by using cached data or delay-based retries.
  \item Network failures are retried up to \texttt{MAX\_RETRIES}.
  \item Fetched data conforms to a consistent JSON schema before validation.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{fetchMetricsFromRepo}(packageID):
\begin{itemize}
  \item transition: sends a GET request via M15 to external repository API.
  \item output: \texttt{metricsData} — structured dictionary of retrieved metrics.
  \item exception: \texttt{APIError} if API call fails or response malformed.
\end{itemize}

\noindent \textbf{validateMetrics}(metricsData):
\begin{itemize}
  \item transition: none.
  \item output: Boolean value indicating if all required metrics are valid.
  \item exception: \texttt{ValidationError} if missing or inconsistent fields.
\end{itemize}

\noindent \textbf{storeValidatedMetrics}(metricsData):
\begin{itemize}
  \item transition: \item transition: submits validated metric records to persistent storage via M10.
  \item output: \texttt{successFlag} = true if stored successfully.
  \item exception: \texttt{WriteError} if database transaction fails.
\end{itemize}

\noindent \textbf{enqueueMetricsFetch}(packageID):
\begin{itemize}
  \item transition: add \texttt{packageID} to \texttt{metricsQueue} for deferred processing.
  \item output: \texttt{successFlag} = true if enqueue succeeds.
  \item exception: \texttt{QueueError} if the request cannot be queued.
\end{itemize}

\noindent \textbf{processMetricsQueue}():
\begin{itemize}
  \item transition: dequeue pending repositories and fetch supported metrics
        via M15; validate and store results via M10.
  \item output: \texttt{successFlag} = true if all queued jobs complete.
  \item exception: \texttt{WorkerError} if processing fails or is interrupted.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{normalizeMetricValues()} — adjusts different metrics to comparable scales before storage.
  \item \texttt{retryFailedRequests()} — retries failed fetch operations respecting delay intervals.
  \item \texttt{updateLastRunTimestamp()} — records timestamp of most recent completed update.
\end{itemize}

\subsection{MIS of Domains Page Module (M9)}
\label{mis:DomainsPage}

\subsubsection{Module}
Implements the logic for presenting and interacting with domain-related data.
This module retrieves, organizes, and displays domains, their associated packages,
metrics, and descriptions, and supports user-driven exploration and filtering
through the defined system interfaces.

\subsubsection{Uses}
Configuration Module (M19)  (\ref{mis:Configuration})\\ 
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway})\\
Graphing Module (M12) (\ref{mis:GraphingModule})\\
Ranking Algorithm Module (M11) (\ref{mis:RankingAlgorithm})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_SORT\_ORDER} = ``alphabetical``
  \item \textbf{MAX\_DISPLAYED\_DOMAINS} = 50
  \item \textbf{DEFAULT\_METRIC\_SET} = [``stars``, ``forks``, ``downloads``]
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
fetchAllDomains & filterOptions & domainList & DatabaseError \\
displayDomainDetails & domainID & renderedView & DataNotFoundError \\
renderDomainMetrics & domainID, metricType & chartObject & RenderError \\
searchDomains & searchTerm & filteredList & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{domainCache}: dictionary storing the most recently viewed domains for quick access.
  \item \textbf{activeFilters}: list of active search or metric filters applied by the user.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item Every entry in \textbf{domainCache} corresponds to a valid domain identifier.
  \item \textbf{activeFilters} only contains filter criteria supported by this module.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{screen}: display surface used to present domain lists and details.
  \item \textbf{inputDevices}: user input sources (mouse, keyboard, touch) used for navigation and filtering.
  \item \textbf{net}: network interface used to retrieve domain data and metrics via M10.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Domain and metric data is available through the System API Gateway (M10).
  \item Users have appropriate permissions (via M6) to view domain data.
  \item Visualization requests are delegated to the Graphing Module (M12).
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{fetchAllDomains}(filterOptions):
\begin{itemize}
  \item transition: none.
  \item output: list of domain objects matching \texttt{filterOptions}.
  \item exception: \texttt{DataAccessError} if domain data cannot be retrieved.
\end{itemize}

\noindent \textbf{displayDomainDetails}(domainID):
\begin{itemize}
  \item transition: retrieves the selected domain’s details and updates the active view.
  \item output: rendered domain view.
  \item exception: \texttt{DataNotFoundError} if the domain ID does not exist.
\end{itemize}

\noindent \textbf{renderDomainMetrics}(domainID, metricType):
\begin{itemize}
  \item transition: retrieves stored metric data for the domain via M10 and delegates visualization to M12.
  \item output: visualization object.
  \item exception: \texttt{RenderError} if visualization fails.
\end{itemize}

\noindent \textbf{searchDomains}(searchTerm):
\begin{itemize}
  \item transition: updates the domain list view with matching results.
  \item output: filtered domain list.
  \item exception: none.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{applyFilters()} — applies active filters to retrieved domain list.
  \item \texttt{updateCache()} — refreshes domain cache with recently accessed data.
  \item \texttt{formatMetricData()} — adjusts metric values for standardized display.
\end{itemize}


\subsection{MIS of Comparison Module (M16)}
\label{mis:Comparison}

\subsubsection{Module}
Implements the logic that defines and manages comparison methods between software packages or domains.  
This module allows users to compare entities based on quantitative metrics (e.g., stars, forks, commits, downloads) and qualitative attributes (e.g., documentation quality, update frequency).  
It serves as a bridge between the user interface, ranking algorithm, and metrics data to compute and display meaningful comparisons.

\subsubsection{Uses}
Ranking Algorithm Module (M11) (\ref{mis:RankingAlgorithm})\\
Graphing Module (M12)  (\ref{mis:GraphingModule})\\
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway}) 

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_METHOD} = ``AHP''
  \item \textbf{SUPPORTED\_METHODS} = [``AHP``, ``BWM``, ``SSB``]
  \item \textbf{DEFAULT\_VISUALIZATION} = ``barChart``
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
selectComparisonMethod & methodName & successFlag & InvalidMethodError \\
computeComparison & domainSet, metricWeights & comparisonTable & ComputationError \\
fetchComparisonData & domainSet & metricsData & DatabaseError \\
visualizeComparison & comparisonTable, chartType & chartObject & RenderError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{activeMethod}: string representing the currently selected comparison method.  
  \item \textbf{comparisonResults}: cached dictionary holding the most recent comparison output.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{activeMethod} $\in$ \texttt{SUPPORTED\_METHODS}.
  \item If \textbf{comparisonResults} is non-empty, it was produced using \textbf{activeMethod}.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{screen}: display surface used to present comparison tables and charts.
  \item \textbf{inputDevices}: user input sources used to select domains/methods and interact with results.
  \item \textbf{net}: network interface used to request comparison data via M10.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Required domain/metric data for comparisons is accessible through M10.
  \item The user selects a valid method from \texttt{SUPPORTED\_METHODS}.
  \item Visualization requests are delegated to M12.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{selectComparisonMethod}(methodName):
\begin{itemize}
  \item transition: updates \texttt{activeMethod}.  
  \item output: \texttt{successFlag} = true if method is supported.  
  \item exception: \texttt{InvalidMethodError} if method not in \texttt{SUPPORTED\_METHODS}.  
\end{itemize}

\noindent \textbf{computeComparison}(domainSet, metricWeights):
\begin{itemize}
  \item transition: requests required metric data via M10 and computes comparison results using the selected method; may delegate scoring/weighting to M11.  
  \item output: \texttt{comparisonTable} containing ranked and weighted scores.  
  \item exception: \texttt{ComputationError} if calculation fails or data incomplete.  
\end{itemize}

\noindent \textbf{fetchComparisonData}(domainSet):
\begin{itemize}
  \item transition: none.  
  \item output: retrieves the metric data required to compare all entities in \texttt{domainSet}.
  \item exception: \texttt{DataAccessError} if data cannot be retrieved through M10.
\end{itemize}

\noindent \textbf{visualizeComparison}(comparisonTable, chartType):
\begin{itemize}
  \item transition: renders visual representation of results via M12.  
  \item output: \texttt{chartObject} representing the visualization of \texttt{comparisonTable}. 
  \item exception: \texttt{RenderError} if graph generation fails.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{normalizeWeights()} — ensures weights sum to 1 before calculation.  
  \item \texttt{computeAHPMatrix()} — performs pairwise comparisons for AHP method.  
  \item \texttt{applyBWM()} — computes ranking scores using Best-Worst Method.  
\end{itemize}


\subsection{MIS of Configuration Module (M19)}
\label{mis:Configuration}

\subsubsection{Module}
Implements the logic for storing, retrieving, and updating configuration data associated with each authenticated user.  
This includes user preferences such as selected visualization settings, default domain filters, notification preferences, and saved comparison parameters.  
It interacts with M5 (User Authentication) to identify the active user and with M17 (Database Persistence Module) for persistent storage of configuration data.

\subsubsection{Uses}
User Authentication Module (M5)  (\ref{mis:UserAuthentication})\\
Database Persistence Module (M17) (\ref{mis:DatabasePersistenceModule})\\
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_LANGUAGE} = ``en''
  \item \textbf{DEFAULT\_THEME} = ``light''
  \item \textbf{DEFAULT\_NOTIFICATION\_SETTINGS} = \{email: true, inApp: true\}
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
getUserConfig & userID & configData & DataNotFoundError \\
updateUserConfig & userID, configData & successFlag & WriteError \\
resetToDefaults & userID & configData & None \\
fetchAllConfigs & None & configList & DatabaseError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{userConfigs}: dictionary mapping each userID to their saved configuration data.  
  \item \textbf{defaultSettings}: dictionary storing global default configuration values.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item For every \textbf{userID} in \textbf{userConfigs}, \textbf{userConfigs(userID)} conforms to the configuration schema.
  \item \textbf{defaultSettings} conforms to the same schema.
\end{itemize}

\paragraph{Environment Variables}
None. This module does not interact with externally supplied
environment configuration values.

\paragraph{Assumptions}
\begin{itemize}
  \item Each userID exists and is validated through M5 before configuration access.  
  \item Configuration data adheres to a predefined JSON schema.  
  \item Default values are stored within this module and initialized at system startup.  
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{getUserConfig}(userID):
\begin{itemize}
  \item transition: none.  
  \item output: returns configuration settings for the given user.  
  \item exception: \texttt{DataNotFoundError} if user has no stored configuration.  
\end{itemize}

\noindent \textbf{updateUserConfig}(userID, configData):
\begin{itemize}
  \item transition: updates stored configuration for the given user in the database.  
  \item output: \texttt{successFlag} = true if update is successful.  
  \item exception: \texttt{WriteError} if database transaction fails.  
\end{itemize}

\noindent \textbf{resetToDefaults}(userID):
\begin{itemize}
  \item transition: resets all stored configuration to default values.  
  \item output: \texttt{configData} reflecting the defaults.  
  \item exception: none.  
\end{itemize}

\noindent \textbf{fetchAllConfigs}():
\begin{itemize}
  \item transition: none.  
  \item output: list of all stored configuration records for administrative view.  
  \item exception: \texttt{DatabaseError} if persistence retrieval fails. 
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{validateConfigSchema()} — ensures submitted configuration matches the JSON schema.  
  \item \texttt{mergeDefaults()} — merges user-provided configuration with stored defaults.  
  \item \texttt{logConfigChange()} — records modification timestamps for audit purposes.  
\end{itemize}


\subsection{MIS of System API Gateway Module (M10)}
\label{mis:SystemAPIGateway}

\subsubsection{Module}
Implements the backend REST API layer that governs communication between the frontend and the server application, and mediates access to persisted data via M17.
This module manages request handling, validation, and serialization across all feature modules.
It ensures that frontend requests are authenticated, validated, and dispatched to the correct internal service routines.


\subsubsection{Uses}
Database Persistence Module (M17) (\ref{mis:DatabasePersistenceModule})\\
User Authentication Module (M5)  (\ref{mis:UserAuthentication})\\
Automated Metrics Module (M8) (\ref{mis:AutomatedMetrics})\\
Repository API Module (M15) (\ref{mis:RepositoryAPIModule})\\
Configuration Module (M19) (\ref{mis:Configuration})\\
User Role Access Module (M6) (\ref{mis:UserRoleAccess})


\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{API\_VERSION} = ``v1''
  \item \textbf{DEFAULT\_CONTENT\_TYPE} = ``application/json''
  \item \textbf{REQUEST\_TIMEOUT\_SEC} = 30
  \item \textbf{MAX\_CONNECTIONS} = 100
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
handleHTTPRequest & request & response & NetworkError \\
authenticate & request & userContext & AuthError \\
authorize & userContext, action & bool & PermissionError \\
validatePayload & endpoint, payload & bool & ValidationError \\
dispatchToModule & endpoint, payload, userContext & serviceOutput & RouteError \\
buildResponse & serviceOutput & response & SerializeError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{routeTable}: mapping of API endpoints to handler routines.
  \item \textbf{middlewareChain}: ordered list of middleware applied to each request (auth, validation, logging).
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item Every endpoint in \textbf{routeTable} maps to exactly one handler routine.
  \item All responses returned by \textbf{handleHTTPRequest} are JSON-serializable.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{DJANGO\_SECRET\_KEY}: secret used to sign cookies/tokens.
  \item \textbf{ALLOWED\_HOSTS}: permitted hostnames for HTTP requests.
  \item \textbf{CORS\_ALLOWED\_ORIGINS}: permitted frontend origins for cross-origin requests.
\end{itemize}


\paragraph{Assumptions}
\begin{itemize}
  \item All endpoints conform to REST conventions (GET, POST, PUT, DELETE).  
  \item Network connections are encrypted via HTTPS.  
  \item Frontend tokens are validated by M5 (User Authentication Module).  
  \item The backend is executed using standard server entry points (development runner and WSGI/ASGI deployment interfaces).
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{handleHTTPRequest}(request):
\begin{itemize}
  \item transition: receives an incoming HTTP request; invokes \texttt{authenticate()} and \texttt{authorize()}; validates the request payload; dispatches the request to the appropriate service routine; serializes the service result into an HTTP response.
  \item output: \texttt{response} containing status code and JSON body.
  \item exception: \texttt{NetworkError} if request handling fails or the request cannot be processed.
\end{itemize}

\noindent \textbf{authenticate}(request):
\begin{itemize}
  \item transition: extracts credentials (e.g., session/JWT token) from \texttt{request} and validates them via M5.
  \item output: \texttt{userContext} (authenticated user identity and session info).
  \item exception: \texttt{AuthError} if credentials are invalid, expired, or missing.
\end{itemize}

\noindent \textbf{authorize}(userContext, action):
\begin{itemize}
  \item transition: checks whether \texttt{userContext} is permitted to perform \texttt{action} using M6.
  \item output: Boolean indicating whether access is permitted.
  \item exception: \texttt{PermissionError} if the user is not authorized for the requested action.
\end{itemize}

\noindent \textbf{validatePayload}(endpoint, payload):
\begin{itemize}
  \item transition: validates \texttt{payload} against the expected schema for \texttt{endpoint}.
  \item output: Boolean indicating whether the payload is valid.
  \item exception: \texttt{ValidationError} if required fields are missing or malformed.
\end{itemize}

\noindent \textbf{dispatchToModule}(endpoint, payload, userContext):
\begin{itemize}
  \item transition: maps \texttt{endpoint} to the appropriate handler routine and invokes the corresponding module/service using \texttt{payload} and \texttt{userContext}.
  \item output: \texttt{serviceOutput} returned by the destination module.
  \item exception: \texttt{RouteError} if \texttt{endpoint} is not mapped to any handler.
\end{itemize}

\noindent \textbf{buildResponse}(serviceOutput):
\begin{itemize}
  \item transition: serializes \texttt{serviceOutput} into a JSON response body and attaches the appropriate HTTP status code.
  \item output: \texttt{response} containing serialized output.
  \item exception: \texttt{SerializeError} if response construction fails.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{serializeResponse()} — converts internal service output into a transferable response format.
  \item \texttt{validateRequest()} — checks incoming request data against the expected schema for the target endpoint.
  \item \texttt{applyMiddleware()} — applies common gateway processing steps (authentication, authorization, logging).
  \item \texttt{logRequest()} — records request and response metadata for monitoring and auditing.
\end{itemize}


\subsection{MIS of Ranking Algorithm Module (M11)}
\label{mis:RankingAlgorithm}

\subsubsection{Module}
Implements ranking algorithms that compute relative scores for software packages
or domains based on weighted criteria. The module supports pairwise-comparison
methods such as Analytic Hierarchy Process (AHP) and is extensible to additional
ranking models (e.g., BWM, SSB). It produces normalized ranking results suitable
for downstream comparison and visualization.

\subsubsection{Uses}
Comparison Module (M16) (\ref{mis:Comparison})\\
Configuration Module (M19) (\ref{mis:Configuration})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_METHOD} = ``AHP``
  \item \textbf{CONSISTENCY\_THRESHOLD} = 0.1
  \item \textbf{SUPPORTED\_METHODS} = [``AHP``, ``BWM``, ``SSB``]
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
computeRankScores & metricsTable, userWeights & rankTable & InvalidMetricError \\
applyAHPWeights & criteriaMatrix & weightedMatrix & MatrixError \\
normalizeScores & rankTable & normalizedTable & NormalizationError \\
getTopPackages & normalizedTable, limit & rankedList & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{criteriaMatrix}: matrix of pairwise criteria comparisons.  
  \item \textbf{normalizedScores}: vector of final ranking results.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{criteriaMatrix}, if defined, is square and has strictly positive entries.
  \item \textbf{normalizedScores}, if defined, sums to 1.
\end{itemize}

\paragraph{Environment Variables}
None. This module does not interact with externally supplied
environment configuration values.

\paragraph{Assumptions}
\begin{itemize}
  \item Criteria weights are positive and consistent within the threshold.  
  \item All metric inputs are validated prior to ranking.  
  \item The consistency ratio for pairwise comparisons does not exceed \texttt{CONSISTENCY\_THRESHOLD}.  
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{computeRankScores}(metricsTable, userWeights):
\begin{itemize}
  \item transition: constructs a weighted decision matrix using the selected ranking method.
  \item output: \texttt{rankTable} — ranked list of packages or domains.  
  \item exception: \texttt{InvalidMetricError} if metrics missing or inconsistent.  
\end{itemize}

\noindent \textbf{applyAHPWeights}(criteriaMatrix):
\begin{itemize}
  \item transition: applies pairwise weights to compute priority vectors.  
  \item output: \texttt{weightedMatrix}.  
  \item exception: \texttt{MatrixError} if dimensions invalid or inconsistent.  
\end{itemize}

\noindent \textbf{normalizeScores}(rankTable):
\begin{itemize}
  \item transition: rescales scores so total weight = 1.  
  \item output: normalized score table.  
  \item exception: \texttt{NormalizationError} if division by 0 or invalid data.  
\end{itemize}

\noindent \textbf{getTopPackages}(normalizedTable, limit):
\begin{itemize}
  \item transition: none.  
  \item output: top-\(n\) ranked packages.  
  \item exception: none.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{checkConsistency()} — calculates consistency ratio for AHP matrices.  
  \item \texttt{aggregateWeights()} — merges user-defined and default weight sets.  
  \item \texttt{normalizeVector()} — scales weight vectors for comparison output.  
\end{itemize}


\subsection{MIS of Graphing Module (M12)}
\label{mis:GraphingModule}

\subsubsection{Module}
Implements visualization operations for presenting metric data and comparison
results. This module generates graphical representations (e.g., bar, line, pie,
or radar charts) from structured input data and produces outputs suitable for
display or export.


\subsubsection{Uses}
System API Gateway Module (M10) (\ref{mis:SystemAPIGateway})\\
Comparison Module (M16)  (\ref{mis:Comparison})\\
Configuration Module (M19)  (\ref{mis:Configuration})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_STYLE} = ``standard''
  \item \textbf{DEFAULT\_FIGSIZE} = (width, height)
  \item \textbf{SUPPORTED\_CHARTS} = [``bar``, ``line``, ``pie``, ``radar``]
  \item \textbf{SUPPORTED\_EXPORT\_FORMATS} = [``png``, ``svg``, ``pdf``]
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
generateGraph & metricData, graphType, config & graphImage & GraphError \\
updateGraphStyle & styleParams & successFlag & StyleError \\
exportGraph & graphImage, format, fileName & exportPath & ExportError \\
renderComparisonPlot & domainMetrics, metricType & comparisonImage & DataError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{currentGraph}: last generated Matplotlib figure object.  
  \item \textbf{styleConfig}: dictionary storing current theme and formatting options.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item If \textbf{currentGraph} is defined, it corresponds to the most recent successful graph generation request.
  \item \textbf{styleConfig} contains only supported visualization parameters.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{screen}: display surface used to present generated visualizations.
  \item \textbf{fs}: file system used to store exported graph images.
  \item \textbf{net}: network interface used to return visualization outputs via M10.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Input datasets contain numeric or categorical values compatible with Matplotlib.  
  \item Configuration settings comply with Matplotlib formatting constraints.  
  \item Graph generation occurs on the backend before transfer to the frontend for rendering.  
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{generateGraph}(metricData, graphType, config):
\begin{itemize}
  \item transition: generates a visualization according to \texttt{graphType} and \texttt{config}.
  \item output: \texttt{graphImage} representing the rendered visualization. 
  \item exception: \texttt{GraphError} if data invalid or plotting fails.  
\end{itemize}

\noindent \textbf{updateGraphStyle}(styleParams):
\begin{itemize}
  \item transition: updates \texttt{styleConfig} (color scheme, font, size).  
  \item output: \texttt{successFlag} = true if update applied.  
  \item exception: \texttt{StyleError} if parameters are unsupported.  
\end{itemize}

\noindent \textbf{exportGraph}(graphImage, format, fileName):
\begin{itemize}
  \item transition: writes \texttt{graphImage} to persistent storage in the requested format. 
  \item output: \texttt{exportPath} of saved image.  
  \item exception: \texttt{ExportError} if write operation fails.  
\end{itemize}

\noindent \textbf{renderComparisonPlot}(domainMetrics, metricType):
\begin{itemize}
  \item transition: overlays multiple data series for comparative visualization.  
  \item output: \texttt{comparisonImage} — rendered comparative plot.  
  \item exception: \texttt{DataError} if inconsistent metric arrays are provided.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{normalizeData()} — ensures all metric values are scaled before plotting.  
  \item \texttt{applyTheme()} — applies style configuration globally.  
  \item \texttt{cleanTemporaryArtifacts()} — removes temporary visualization artifacts after export. 
\end{itemize}


\subsection{MIS of File Import Module (M13)}
\label{mis:FileImportModule}

\subsubsection{Module}
Handles ingestion of user-provided data files and converts them into structured
datasets for internal use. This module parses, validates, and transforms CSV or
spreadsheet files into records conforming to the system's domain and metric
schemas, and forwards validated data for persistence through the backend API.

\subsubsection{Uses}
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway})\\
Configuration Module (M19) (\ref{mis:Configuration})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{SUPPORTED\_FORMATS} = [``csv``, ``xlsx``]
  \item \textbf{MAX\_FILE\_SIZE\_MB} = 10
  \item \textbf{DEFAULT\_ENCODING} = ``utf-8``
  \item \textbf{REQUIRED\_FIELDS} = [``DomainName``, ``PackageName``, ``MetricName``, ``Value``]
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
parseFile & filePath, fileType & dataFrame & ParseError \\
validateImportedData & dataFrame & bool & ValidationError \\
storeImportedData & dataFrame & successFlag & WriteError \\
getImportSummary & dataFrame & summaryDict & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{lastImportedFile}: path or identifier of the last processed file.  
  \item \textbf{importStatus}: status flag indicating the most recent operation result.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{importStatus} reflects the outcome of the most recent import attempt.
  \item If \textbf{lastImportedFile} is defined, it refers to the most recently processed input.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{fs}: file system interface used to read uploaded files.
  \item \textbf{encoding}: externally determined character encoding for text files.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Uploaded files conform to the system’s schema and naming conventions.  
  \item File size and encoding are supported and within defined constraints.  
  \item Invalid rows are filtered out and logged, not silently dropped.  
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{parseFile}(filePath, fileType):
\begin{itemize}
  \item transition: reads the input file and transforms it into a structured dataset representation.
  \item output: \texttt{dataFrame} containing structured data.  
  \item exception: \texttt{ParseError} if the file cannot be opened or parsed.  
\end{itemize}

\noindent \textbf{validateImportedData}(dataFrame):
\begin{itemize}
  \item transition: checks for required fields and data-type consistency.  
  \item output: Boolean indicating whether validation succeeded.  
  \item exception: \texttt{ValidationError} if mandatory columns are missing or invalid types detected.  
\end{itemize}

\noindent \textbf{storeImportedData}(dataFrame):
\begin{itemize}
  \item transition: submits validated records to the backend via M10 for persistence.
  \item output: \texttt{successFlag} = true if the backend acknowledges storage.
  \item exception: \texttt{WriteError} if persistence fails or is rejected.
\end{itemize}


\noindent \textbf{getImportSummary}(dataFrame):
\begin{itemize}
  \item transition: none.  
  \item output: \texttt{summaryDict} — total rows processed, valid, invalid, and stored.  
  \item exception: none.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{cleanColumnNames()} — standardizes column names to match system schema.  
  \item \texttt{detectDelimiter()} — determines delimiter automatically for CSV files.  
  \item \texttt{logImportActivity()} — records metadata of each file import for traceability.  
\end{itemize}


\subsection{MIS of File Export Module (M14)}
\label{mis:FileExportModule}

\subsubsection{Module}
Handles transformation of system data into exportable file formats such as CSV
or spreadsheet files. This module gathers domain, metric, and ranking data from
the backend services, converts it into standardized export records, and writes
files suitable for external analysis tools while preserving schema and encoding.

\subsubsection{Uses}
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway})\\
Configuration Module (M19)  (\ref{mis:Configuration})\\
Ranking Algorithm Module (M11)  (\ref{mis:RankingAlgorithm})

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{SUPPORTED\_FORMATS} = [``csv``, ``xlsx``]
  \item \textbf{DEFAULT\_ENCODING} = ``utf-8``
  \item \textbf{MAX\_ROWS\_PER\_FILE} = 50000
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
prepareExportData & queryParams, dataType & exportData & DataError \\
exportToCSV & exportData, fileName & filePath & WriteError \\
exportToExcel & exportData, fileName & filePath & WriteError \\
getExportSummary & filePath & summaryDict & None \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{exportStatus}: status flag of the latest export operation.  
  \item \textbf{lastExportFile}: file name of the most recently generated export.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item If \textbf{exportStatus} indicates success, then \textbf{lastExportFile} refers to a file created in the most recent export.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{fs}: file system interface used to create and write export files.
  \item \textbf{encoding}: externally determined encoding used for text exports.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Data requested for export is already validated and normalized.  
  \item User export requests specify supported formats only.  
  \item The file system path \texttt{EXPORT\_DIRECTORY} is writable by the application.  
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{prepareExportData}(queryParams, dataType):
\begin{itemize}
  \item transition: requests the required records via M10 using \texttt{queryParams} and \texttt{dataType}.
  \item output: \texttt{exportData} containing normalized records ready for serialization.
  \item exception: \texttt{DataError} if retrieval fails or returns incomplete data.
\end{itemize}

\noindent \textbf{exportToCSV}(exportData, fileName):
\begin{itemize}
  \item transition: serializes \texttt{exportData} into CSV and writes the file via \textbf{fs}.
  \item output: \texttt{filePath} of the generated CSV file.
  \item exception: \texttt{WriteError} if file I/O fails.
\end{itemize}

\noindent \textbf{exportToExcel}(exportData, fileName):
\begin{itemize}
  \item transition: serializes \texttt{exportData} into spreadsheet format and writes the file via \textbf{fs}.
  \item output: \texttt{filePath} of the generated spreadsheet file.
  \item exception: \texttt{WriteError} if file I/O fails.
\end{itemize}


\noindent \textbf{getExportSummary}(filePath):
\begin{itemize}
  \item transition: none.  
  \item output: \texttt{summaryDict} — includes file name, record count, and format.  
  \item exception: none.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{sanitizeFileName()} — ensures export file names are safe and standardized.  
  \item \texttt{splitLargeExports()} — divides large datasets into multiple files if row limit exceeded.  
  \item \texttt{logExportActivity()} — records export metadata for auditing.  
\end{itemize}


\subsection{MIS of Repository API Module (M15)}
\label{mis:RepositoryAPIModule}

\subsubsection{Module}
Provides an interface for interacting with external repository APIs such as GitHub, GitLab, and PyPI.  
This module retrieves repository metadata and metric data (e.g., stars, forks, issues, commits) required for domain analysis.  
It handles authentication, rate limiting, and response parsing before returning validated data to internal modules.

\subsubsection{Uses}
System API Gateway Module (M10) [for backend communication] (\ref{mis:SystemAPIGateway})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{REQUEST\_TIMEOUT\_SEC} = 30
  \item \textbf{MAX\_RETRIES} = 3
  \item \textbf{RATE\_LIMIT\_THRESHOLD} = 1000
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
setAuthToken & token & successFlag & AuthError \\
fetchRepoMetadata & packageID & repoData & APIError \\
fetchRepoMetrics & packageID, metricList & metricsData & APIError \\
handleRateLimit & responseHeaders & delaySeconds & RateLimitError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{authToken}: authentication key for accessing external APIs.  
  \item \textbf{lastResponseStatus}: HTTP status code of the most recent request.  
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item If \textbf{authToken} is defined, it is valid for at least one external repository service.
  \item \textbf{lastResponseStatus} reflects the most recent external API interaction.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{net}: network interface used to communicate with external repository services.
  \item \textbf{clock}: system clock used to evaluate rate limits and retry delays.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item External repository services expose stable interfaces for retrieving metadata and metrics.
  \item Rate limiting information is provided by external services and respected by this module.
  \item Authentication credentials for external services are available to this module.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{setAuthToken}(token):
\begin{itemize}
  \item transition: sets a new authentication token for subsequent API calls.  
  \item output: \texttt{successFlag} = true if token successfully stored.  
  \item exception: \texttt{AuthError} if token invalid or missing permissions.  
\end{itemize}

\noindent \textbf{fetchRepoMetadata}(packageID):
\begin{itemize}
  \item transition: requests repository metadata from an external repository service.
  \item output: \texttt{repoData} containing repository metadata attributes.    
  \item exception: \texttt{APIError} if request fails or JSON malformed.  
\end{itemize}

\noindent \textbf{fetchRepoMetrics}(packageID, metricList):
\begin{itemize}
  \item transition: requests the specified metrics for the repository from an external service.
  \item output: \texttt{metricsData} containing retrieved metric values.
  \item exception: \texttt{APIError} if any metric endpoint fails or rate-limited.  
\end{itemize}

\noindent \textbf{handleRateLimit}(responseHeaders):
\begin{itemize}
  \item transition: calculates required delay based on rate-limit headers.  
  \item output: \texttt{delaySeconds} = integer number of seconds to wait.  
  \item exception: \texttt{RateLimitError} if headers missing or malformed.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{parseResponse()} — converts external service responses into internal data structures.
  \item \texttt{retryRequest()} — retries failed external requests up to \texttt{MAX\_RETRIES}.
  \item \texttt{logAPICall()} — records external API interactions for monitoring and diagnostics.
\end{itemize}


\subsection{MIS of Database Persistence Module (M17)}
\label{mis:DatabasePersistenceModule}

\subsubsection{Module}
Provides persistent storage services for the system's domain, package, metric, and user data.
This module encapsulates all interactions with the relational database, ensuring data integrity,
schema consistency, and transactional reliability for all read/write operations.

\subsubsection{Uses}
None.

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DB\_TIMEOUT\_SEC} = 15
  \item \textbf{AUTO\_COMMIT} = true
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
createEntity & entityType, entityData & entityID & WriteError \\
readEntity & entityType, query & entitySet & NotFoundError \\
updateEntity & entityType, entityID, patch & successFlag & WriteError \\
deleteEntity & entityType, entityID & successFlag & DeleteError \\
executeQuery & querySpec & queryResult & QueryError \\
\bottomrule
\end{tabularx}
\end{center}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{connectionPool}: pool of reusable relational database connections.
  \item \textbf{lastTransactionStatus}: Boolean flag indicating success or failure of the last query.
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item All committed database operations preserve referential integrity among stored entities.
  \item If \textbf{lastTransactionStatus} = true, the most recent operation was committed successfully.
\end{itemize}

\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{DB\_HOST}: address of the database server.
  \item \textbf{DB\_PORT}: port used to connect to the database server.
  \item \textbf{DB\_USER}: database username credential.
  \item \textbf{DB\_PASSWORD}: database password credential.
  \item \textbf{DB\_NAME}: logical database name containing system tables.
  \item \textbf{DB\_URL} (optional): single connection string that may replace the variables above.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item Database schema remains stable (UC1).
  \item Schema changes (if any) are version-controlled and applied through the system’s database migration mechanism.
  \item Connection credentials are valid and not hard-coded.
\end{itemize}

\paragraph{Access Routine Semantics}

\noindent \textbf{createEntity}(entityType, entityData):
\begin{itemize}
  \item transition: inserts a new entity record of type \texttt{entityType} using \texttt{entityData}.
  \item output: \texttt{entityID} identifying the created entity.
  \item exception: \texttt{WriteError} if the operation violates constraints or cannot be committed.
\end{itemize}

\noindent \textbf{readEntity}(entityType, query):
\begin{itemize}
  \item transition: none.
  \item output: \texttt{entitySet} containing all entities of type \texttt{entityType} matching \texttt{query}.
  \item exception: \texttt{NotFoundError} if no matching entities exist.
\end{itemize}

\noindent \textbf{updateEntity}(entityType, entityID, patch):
\begin{itemize}
  \item transition: applies \texttt{patch} updates to the entity identified by \texttt{entityID}.
  \item output: \texttt{successFlag} = true if the update is committed.
  \item exception: \texttt{WriteError} if the entity does not exist or the update cannot be committed.
\end{itemize}

\noindent \textbf{deleteEntity}(entityType, entityID):
\begin{itemize}
  \item transition: removes the entity identified by \texttt{entityID} if permitted by integrity constraints.
  \item output: \texttt{successFlag} = true if deletion is committed.
  \item exception: \texttt{DeleteError} if deletion is blocked by constraints or cannot be committed.
\end{itemize}

\noindent \textbf{executeQuery}(querySpec):
\begin{itemize}
  \item transition: executes the database operation described by \texttt{querySpec}.
  \item output: \texttt{queryResult} containing the resulting dataset or status.
  \item exception: \texttt{QueryError} if the query is invalid or execution fails.
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{openConnection()} — establishes or obtains a database connection for an operation.
  \item \texttt{commitOrRollback()} — commits successful operations or rolls back on failure.
  \item \texttt{logDBActivity()} — records persistence operations for monitoring and diagnostics.
\end{itemize}


\subsection{MIS of Logging Module (M18)}
\label{mis:LoggingModule}

\subsubsection{Module}
Provides centralized logging services for recording and retrieving system events and user actions.
This module supports traceability, debugging, and auditing by accepting log entries from backend services
and persisting them in a configurable log store.

\subsubsection{Uses}
System API Gateway Module (M10)  (\ref{mis:SystemAPIGateway})\\
Database Persistence Module (M17) (\emph{optional; only if} \texttt{storeType = DB}) (\ref{mis:DatabasePersistenceModule})\\

\subsubsection{Syntax}

\paragraph{Exported Constants}
\begin{itemize}
  \item \textbf{DEFAULT\_LEVEL} = ``INFO``
  \item \textbf{MAX\_LOG\_SIZE\_MB} = 10
  \item \textbf{BACKUP\_COUNT} = 5
\end{itemize}

\paragraph{Exported Access Programs}
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{l X X l}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\midrule
initLogger & logConfig & successFlag & ConfigError \\
logEvent & message, level, context & successFlag & WriteError \\
getRecentLogs & limit, [filter:LogFilter] & list(LogEntry) & ReadError \\
archiveLogs & None & successFlag & ArchiveError \\
\bottomrule
\end{tabularx}
\end{center}

\paragraph{Data Types}
\begin{itemize}
  \item \textbf{LogLevel} ::= \{\texttt{DEBUG}, \texttt{INFO}, \texttt{WARNING}, \texttt{ERROR}, \texttt{CRITICAL}\}
  \item \textbf{LogEntry} ::= $\langle timestamp:string, level:LogLevel, message:string, context:dict(string,string) \rangle$
  \item \textbf{LogFilter} ::= $\langle minLevel:Option(LogLevel), containsText:Option(string) \rangle$
  \item \textbf{LogConfig} ::= $\langle storeType:\{\texttt{FILE},\texttt{DB}\}, level:LogLevel, fileName:Option(string) \rangle$
\end{itemize}

\subsubsection{Semantics}

\paragraph{State Variables}
\begin{itemize}
  \item \textbf{activeLogger}: configured logger instance handling writes.
  \item \textbf{logLevel}: current logging verbosity threshold.
  \item \textbf{logBuffer}: queue of pending log entries awaiting persistence (if asynchronous logging is used).
\end{itemize}

\paragraph{State Invariant}
\begin{itemize}
  \item \textbf{activeLogger} is initialized before any successful call to \texttt{logEvent()} or \texttt{getRecentLogs()}.
  \item \textbf{logLevel} $\in$ \{\texttt{DEBUG}, \texttt{INFO}, \texttt{WARNING}, \texttt{ERROR}, \texttt{CRITICAL}\}.
  \item If \textbf{logBuffer} is used, then $0 \le |\textbf{logBuffer}|$ and all buffered entries have a well-formed timestamp, level, and message.
  \item Every persisted log entry contains at minimum: \texttt{timestamp}, \texttt{level}, and \texttt{message}.
\end{itemize}


\paragraph{Environment Variables}
\begin{itemize}
  \item \textbf{clock}: system clock used for timestamps.
  \item \textbf{logDir}: directory/location for log storage if file-based.
\end{itemize}

\paragraph{Assumptions}
\begin{itemize}
  \item File system permissions allow append and rotation of log files.  
  \item Log directory structure already exists and is writable by the application.  
  \item Critical events (ERROR, CRITICAL) are monitored through external observability tools if configured.  
\end{itemize}

\paragraph{Project Configuration Note}
For the peer-implementation deliverable and the current system release,
\texttt{logConfig.storeType = FILE}. Therefore, persistence and retrieval are file-based under
\texttt{logDir}. Database persistence via M17 is supported by this MIS but is not required for the peer implementation.
If \texttt{fileName = None}, the implementation shall use \texttt{app.log}.



\paragraph{Access Routine Semantics}

\noindent \textbf{initLogger}(logConfig):
\begin{itemize}
  \item transition: initializes the logger with parameters defined in logConfig.  
  \item output: \texttt{successFlag} = true if initialization succeeds.  
  \item exception: \texttt{ConfigError} if logConfig invalid or missing keys.  
\end{itemize}

\noindent \textbf{logEvent}(message, level, context):
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Create \texttt{entry : LogEntry} using the current \texttt{clock} for \texttt{timestamp}.
    \item If \texttt{level} is below the configured threshold \texttt{logLevel}, do not persist and return \texttt{successFlag = false}.
    \item If \texttt{logConfig.storeType = FILE}, append \texttt{entry} to \texttt{logDir/fileName} (default \texttt{app.log} if \texttt{fileName = None}).
    \item If \texttt{logConfig.storeType = DB}, persist \texttt{entry} via the Database Persistence Module (M17).
  \end{itemize}
  \item output: \texttt{successFlag} indicates whether the entry was persisted.
  \item exception: \texttt{WriteError} if the configured log store cannot be written.
\end{itemize}


\noindent \textbf{getRecentLogs}(limit, [filter]):
\begin{itemize}
  \item transition: reads entries, applies \texttt{filter} if provided, then returns the most recent \texttt{limit} entries.
  \item output: \texttt{logsList : list(LogEntry)} containing up to \texttt{limit} most recent entries matching \texttt{filter} if provided.
  \item exception: \texttt{ReadError} if logs cannot be retrieved.
\end{itemize}



\noindent \textbf{archiveLogs}():
\begin{itemize}
  \item transition: compresses and rotates existing log files once they exceed \texttt{MAX\_LOG\_SIZE\_MB}.  
  \item output: \texttt{successFlag} = true if archiving succeeds.  
  \item exception: \texttt{ArchiveError} if file rotation fails.  
\end{itemize}

\paragraph{Local Functions}
\begin{itemize}
  \item \texttt{formatLogEntry()} — attaches timestamp, severity, and context metadata.
  \item \texttt{rotateIfNeeded()} — triggers log rotation/archival when thresholds are exceeded.
  \item \texttt{emitAlert()} — notifies monitoring systems for severe events if configured.
\end{itemize}



\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}
\subsection{Appendix --- Module Hierarchy Diagram}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/Use_Hierarchy_Diagram.drawio.PNG}
    \caption{Module Hierarchy for DomainX}
    \label{fig:modulehierarchy}
\end{figure}
% \wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

% \wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  
  Awurama: We had a clear module hierarchy and strong alignment with the MG, 
  which made structuring each MIS section easier. Collaboration and consistency across modules also improved clarity.
  
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  
  Awurama: Managing LaTeX formatting, especially tables and long text, was time-consuming. 
  We fixed these by using the tabularx package and standardizing our template for all modules.
  
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  
  Awurama: Most design choices came from client discussions with Dr. Smith and feedback from peers. 
  For example, decisions on automation scope, ranking algorithms, 
  and database structure came directly from those conversations.
  
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  
  Awurama: We refined sections of the SRS and MG for consistency,
  mainly updating module responsibilities and interfaces to match the finalized MIS content.
  
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  
  Awurama: Limited time and resources meant we couldn’t build full scalability or advanced automation. 
  With more resources, we’d expand integration testing, optimize APIs, and improve real-time analytics.
  
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  
  Awurama: We considered using a non-relational database and different frontend frameworks but chose Django/MySQL and React 
  for reliability and maintainability. Alternatives offered flexibility but added complexity and reduced team familiarity.

  (LO\_Explores)
\end{enumerate}

\textbf{Peer Implementation Reflection:}

  Implementing team 25's module was very manageable because the MIS clearly listed the exported constants and exported access
  programs which gave a strong starting point for the structure and naming. The most helpful part of the MIS was the access routine,
  since it clearly stated the expected conversion approach (repeated division and remainder for decimal to dozenal, 
  and the positional evaluation for dozenal to decimals). The main challenge i think however was that the MIS did not fully define the allowed 
  digit-symbol mapping for the two extra dozenal digits beyond 0-9, so some of the implementation choices made required assumptions 
  to a level (e.g., choosing \texttt{X} and \texttt{E} as canonical symbols and supporting alternate inputs). 
  Another difficulty was deciding how strict i should make normalization, especially around things like handling whitespace, casing, optional
  plus signs, and the leading zeros. 

  To improve implementability, the MIS could include explicit examples of valid and invalid dozenal
  strings, plus sample inputs and outputs for each access program (including edge cases like 0, negative numbers, and error
  strings). This process really helped to reinforce the importance of specifying specific or rather strict input validation rules and canonical formatting 
  expectations inside the MIS so people implementing do not rely on interpretation or assumption (but i guess you always have to to some extent). 
  Overall, implementing this module helped confirm
  how small missing details in a specification can affect consistency across different implementations, but a good MIS can still make implementation manageable.

  \paragraph{Reflection on Another Team's Implementation (M18).}
  Team 22's implementation of our M18 Logging Module mostly matched the MIS well (same exported access programs, exceptions, 
  log levels, \texttt{LogEntry} fields, and the \texttt{logEvent} threshold behavior). The main issue 
  I noticed was around \texttt{archiveLogs()} when using \texttt{RotatingFileHandler}: rotation can happen automatically
   during logging, which can make \texttt{archiveLogs()} do nothing afterward because \texttt{app.log} becomes small again. 
   This showed me that the MIS needs to be more explicit about how archiving should work with automatic rotation and how
    compression/retention should be handled (for example, whether compression happens during rollover, and how backups are
     kept and named).



\end{document}